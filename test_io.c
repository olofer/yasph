#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include "textio.h"

int main(int argc, const char** argv)
{
  if (argc != 7) {
    printf("usage: %s testname M N randomflag headerflag filename\n", argv[0]);
    return 1;
  }

  const bool csv_test = strcmp(argv[1], "csv-write-read") == 0;
  const bool tsv_test = strcmp(argv[1], "tsv-write-read") == 0;
  const bool ssv_test = strcmp(argv[1], "ssv-write-read") == 0;

  if (!csv_test && !tsv_test && !ssv_test) {
    printf("test identifier \"%s\" was not recognized\n", argv[1]);
    return 1;
  }

  const int M = atoi(argv[2]);
  const int N = atoi(argv[3]);

  if (M <= 0 || N <= 0) {
    printf("M, N > 0 required\n");
    return 1;
  }

  const int randomflag = atoi(argv[4]);
  const bool use_random_data = (randomflag != 0);

  const int headerflag = atoi(argv[5]);
  const bool write_head_comment = (headerflag != 0);

  char head_comment[1000];
  if (write_head_comment) {
    head_comment[0] = '\0';
    strcat(head_comment, "generated by: ");
    for (int i = 0; i < argc; i++) {
      strcat(head_comment, argv[i]);
      strcat(head_comment, " ");
    }
  }

  const char* tempfile = argv[6];

  const char sep_char = (csv_test ? ',' : (tsv_test ? '\t' : ' '));

  bool test_success = false;
  bool test_success_tr = false;

  double* data = (double *) malloc(M * N * sizeof(double));

  if (use_random_data) {
    for (int e = 0; e < M * N; e++) {
      data[e] = -1.0 + 2.0 * ((double) rand()) / RAND_MAX; 
    }
  } else {
    for (int e = 0; e < M * N; e++) {
      data[e] = (double) e; 
    }
  }

  const int write_return_code = textio_write_double_matrix(tempfile, 
                                                           data, 
                                                           M, 
                                                           N, 
                                                           NULL, 
                                                           sep_char,
                                                           write_head_comment ? head_comment : NULL,
                                                           NULL);

  if (write_return_code != M * N) {
    free(data);
    return 2;
  }

  const bool detectComments = true;

  double* read_data = NULL;
  int read_m = 0, read_n = 0;
  const int read_return_code = textio_read_double_matrix(tempfile, 
                                                         &read_data, 
                                                         &read_m, 
                                                         &read_n, 
                                                         TEXTIO_COLUMNMAJOR, 
                                                         sep_char,
                                                         detectComments);
  test_success = (read_return_code == M * N && 
                  M == read_m && 
                  N == read_n && 
                  read_data != NULL);

  if (test_success) {
    for (int e = 0; e < M * N; e++) {
      if (read_data[e] != data[e]) {
        test_success = false;
        break;
      }
    }
  }

  double* read_data_tr = NULL;
  int read_m_tr = 0, read_n_tr = 0;
  const int read_return_code_tr = textio_read_double_matrix(tempfile, 
                                                            &read_data_tr, 
                                                            &read_m_tr, 
                                                            &read_n_tr, 
                                                            TEXTIO_ROWMAJOR, 
                                                            sep_char,
                                                            detectComments);
  test_success_tr = (read_return_code_tr == M * N && 
                     M == read_m_tr && 
                     N == read_n_tr && 
                     read_data_tr != NULL);

  if (test_success_tr) {
    for (int r = 0; r < M; r++) {
      for (int c = 0; c < N; c++) {
        if (data[r + c * M] != read_data_tr[c + N * r]) {
          test_success_tr = false;
          break;
        }
      }
    }
  }

  free(data);
  if (read_data != NULL) free(read_data);
  if (read_data_tr != NULL) free(read_data_tr);

  return ((test_success && test_success_tr) ? 0 : -1);
}
